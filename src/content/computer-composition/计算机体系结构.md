### 计算机体系结构 computer system architecture


#### 计算机物理组织
> 

#### 计算机系统
> 读取并执行程序的中央处理单元(central processing unit,CPU)
> 保存程序和数据的存储器
> 芯片转换为实用系统的其他子系统

#### CPU
> 计算机性能取决于cpu,也取决于其他子系统的性能.
> 提高cpu只是更早等待存储器或磁盘驱动器的数据
    
> 信息保存在存储器中,根据不同目的,使用不同存储器
> 绝大cpu内集cache

#### 什么是计算机
> 接收并处理输入信息,产生输出结果的可编程数字计算机

- 通用计算机
    > 因为硬件(即实际的数字电路)是按照程序的指示完成工作,通过硬连线的方式.
- 存储程序计算机
    - 中央处理单元
        > 读取程序并完成程序指定的操作
    - 存储器系统
        > 保存程序和处理的数据
    - 执行流程:
        > 在程序控制下,cpu与存储器传送数据
        - 写周期
            > 程序产生的数据从cpu写入存储器
        - 读周期
            > cpu请求的数据从存储器送往cpu


        - 实例:从存储器中读出两个数(x和y)相加,然后将和写回存储器
            > cpu首先从存储器中取出指令,解码指令后,从存储器中读出指令所需数据
            1. LOAD X,存储器读出x值,并存入寄存器
            2. LOAD Y,存储器读出y值,并存入寄存器
            3. Z=X+Y,将两个寄存器内容相加,报错结果存入寄存器
            4. STORE Z, 将加法的结果写回存储单元Z

        > 大多数计算机CPU和存储器系统只有一条信息通路,数据和指令要轮流使用

    - 哈佛体系结构(Harvard architecture)
        > 数据和指令存放在不同存储器中(或者使用不同总线传输数据和指令) 

#### 体系结构和组成
- 计算机体系结构
    > 通常被称为 指令集体系结构(instruction set architecture,ISA)
    - 指令集体系结构包含:
        1. 数据类型 (每个字的位数以及各个为的含义)
        2. 保存临时结果的寄存器
        3. 指令的类型和方式
        4. 寻址方式 (数据在寄存器存放位置的方法)

- 计算机组成
    > 表示其体系结构的具体实现,用 微体系结构(microarchitecture)


#### 计算机系统和技术
- 摩尔定律:
    > 芯片的集成度每18个月翻一番

- 时钟
    > 产生连续的间隔固定的电脉冲流,电脉冲流来计时或确定计算机内事件的顺序
    - 如何来定义?
        - 重复速率或频率来定义
        - 时钟脉冲的宽度或持续时间,即 频率的倒数(f=1/T)

    - 同步和异步?
        - 同步
            > 由时钟信号触发的数字电路称为同步
        - 异步
            > 发生在任何时间的事件
        - 实例:
            > 移动鼠标,向计算机发送信号,异步事件
            > 每个时钟脉冲检测鼠标的状态,同步事件


#### 计算机的发展
- 机械计算机
    1. 1642年,法国数学家 布莱士·帕斯卡(Blaise Pascal),设计机械加减法计算装置,基础发条计算
    2. 1694年,德国数学家 弗里德·威廉·莱布尼茨(Gottfried wilhelm Leibnite),复杂机械计算器,进行四则运算
    > 由于无法编程,所以不能称为现代意义上的计算机
    3. 1882年,英格兰 查尔斯·巴贝奇(Charles Babbage) 设计叫做差分机的计算装置,进行多项式运算,本质是分析机(analytical engine)
    4. 1855年,瑞典 Per Georg Scheutz 发明差分机
    5. 奥古斯塔·阿达·金(Augusta Ada King),英国作家,数学家于1842年翻译意大利数学家路易吉·蒙博(Luigi Menabrea)所撰写的关于分析机的备忘录,被称为编写计算机程序的第一人

- 机电式计算机
    > 电话交换装置使用继电器的机电开关,像二进制逻辑开关元件,制造机电式计算机
    1. 20世纪40年代,德国康拉德·楚泽(Konrad Zuse)视作电子计算机的发明者
        > 可编程计算机
        > 设计第一种程序设计语言,PlanKalkul
    2. 1944年,哈佛大学 霍华德·艾肯(Howard Aiken) 马克I号机机电式计算机,
        > 可编程,但不支持条件操作,所以不能称为今天意义上的计算机

- 早期的电子计算机
    1. 1937~1942年,约翰·文森特·阿塔那索夫(John V.Atanasoff)制造出第一台电子计算机(ABC),解线性方程
    2. 1944年,巨像计算机(Colossus),另一台早期计算机
    3. 1945年,J.莫奇利(J. Mauchly)和J.埃克特(J. Eckert)
        > 设计了ENIAC,执行指定操作,操作信息通过硬连线发送到电路中.
        > 设计EDVAC,具有存储程序特征
    4. 1948年,英国曼彻斯特大学,设计出世界第一台可操作的存储程序计算机,曼彻斯特宝宝
    > 存储程序或冯·诺伊曼计算机时今天计算机的基础,指令和数据存储在存储器
    5. Ferranti公司,对曼彻斯特宝宝进行改造,设计出欧洲第一台存储计算机,EDSAC
    6. 1948年,AT&T贝尔实验室,发明晶体管,随后发展出半导体
        > 与真空管等效,体积更小,功耗更低
    7. 20世纪60年代中期,IBM设计出System/360体系结构,兼容和互操作小型商务机到科学计算大型机,出现了指令集体系结构

- 微机和pc革命
    > 集成电路技术为微型计算机(如DEC公司制造的PDP-8)铺平道路
    1. 20世纪70年代,大学的系和小型组织可购买小型机(微机)
    2. 20世纪70年代,Intel和摩托罗拉都发布了8位微处理器
    3. 1975年,MITS公司发布Altair 8000 微机
    4. 1976年苹果I和1977年苹果II上市,最早拥有可用软件和外设的商用微机
    5. 摩托罗拉设计68000(32位微机),以此为基础,苹果于20世纪80年代推出mac计算机
    6. Atari(预示游戏技术),Commodore(Amiga是多媒体计算机的先驱)
    7. 20世纪80年代推出个人电脑(PC机)
        > 由于开放式体系结构,pc机在三方软,硬件开发者流行起来
        > Intel 发展16位80286(1982年),32位80386(1985年),64位Pentium(1990年),2000年Intel统治PC机市场
    8. 20世纪80年代,RISC革命
        - 指令流水线,它将处理器编程自动生产线执行指令的工厂,4条或更多的指令可以在流水线不同阶段同时执行
        - 超标量处理
            > 从存储器中读出几条指令,并行执行
        - 乱序执行
            > 允许当前指令等待正被使用的资源时执行程序靠后的指令

- 存储技术发展
    > 磁盘使得pc革命成为现实
    > 磁盘一直用来存储数据和程序
    1. 20世纪30年代,约翰·文森特·阿塔纳索夫(John V.Atanasoff)发明最早的存储设备,覆盖电容的磁鼓,可充电并存储1和0
    2. 英国曼切斯特大学,弗雷里克·威廉姆斯(Frederick Williams)发明第一个快速数据存储设备
        > 第一代存储1024比特
        > 第二代存储2048比特
    3. 1949年,佛瑞斯特(Forester),美国,设计铁氧体磁芯存储器
    4. 20世纪70年代,铁氧体磁芯存储器成为大型机主流存储器
    5. 20世纪70年代,发明半导体动态存储器,替代磁芯存储器
    6. 1956年,IBM,统计控制随机存取方法(RAMAC)引入了磁盘存储机制,将数据保存在一个旋转的磁盘表面
    > 现代磁盘的容量是RAMAC的数百万倍,但其速度的发展不均衡

- 普适计算
    > 趋同性,功能穿越不同移动设备的界限
    > 功耗感知(power-aware)计算,功耗感知与低功耗计算的含义相同

- 多媒体计算机
    > 多媒体处理是现代计算机的重要特征

- 存储程序计算机
    > ARM系列计算机和Intel IA-64体系结构的计算机
    - 实例:找出最大游程是多少?
        > 23277366664792221
        - 解决思路:从数串左边开始逐个检查数字,在任何位置,
            > 我们会得到数与之前相同,序列增长
            > 数字不同,前一个序列结束,从新序列开始
        
        - 转化成数值表
            | 在串中的位置 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8|9|10|11|12|13|14|15|16|17|
            | 元素值 | 2|3|2|7|7|3|6|6|6|6|4|7|9|2|2|2|1|
            | 当前序列数值|?|2|3|2|7|7|3|6|6|6|6|4|7|9|2|2|2|
            | 当前序列长度|1|1|1|1|2|1|1|2|3|4|1|1|1|1|2|3|1|
            | 最大序列长度|1|1|1|1|2|2|2|2|3|4|4|4|4|4|4|4|4|
        
        - 构建算法
            - 使用符号名抽象:
                1. i 串的当前位置
                2. New_Digit 刚从数串中读出的数字和值
                3. Current_Run_Value 当前序列数值
                4. Current_Run_length 当前序列长度
                5. Max_Run 目前为止的最大序列长度
            
            - 伪代码:
                1. 读出串的第一个数字,将其称为New_Digit
                2. 将Current_Run_Value的值置为New_Digit
                3. 将Current_Run_Length的值置为1
                4. 将Max_Run的值置为1
                5. REPEAT
                6. 读出序列中下一个数字(即 read New_Digit)
                7. IF 它的值与 Current_Run_Value 相同
                8.      THEN Current_Run_Length = Current_Run_Length + 1
                9.      ELSE \{ Current_Run_Length = 1
                10.           Current_Run_Value = New_Digit\}
                11. IF Current_Run_Length > Max_Run
                12.           THEN Max_Run = Current_Run_Length
                13. UNITL 读出最后一个数字
        
        - 计算机解决什么问题?
            > 顺序执行,每次执行一句
            - 都干了什么事情？
                1. 读出数字,保存至存储器某处,符号名New_Digit指明存储器位置.使用此索引可通过存储器访问值
                2. 进行赋值,将值赋给变量
                3. 将Current_Run_Length赋值为1
                4. 将Max_Run赋值为1
                    > 3和4必须从存储器中读出数,修改并重写回存储器
                5. 将被执行一次或多次的起始位置
                6.  略
                7. 比较读出的值与当前序列的值是否相同(New_Digit == Current_Run_Value)?
                8. THEN 后的文字指定
                9. ELSE 后的文字指定
                10. 同上
                11. 比较读出的值是否大于当前序列的值(New_Digit < Current_Run_Value)?
                12. THEN 后的文字指定
                13. 结束一次或多次执行

        - 存储器